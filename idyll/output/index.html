<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, minimum-scale=1.0"
    />
    <title>Idyll</title>
    <meta property="og:title" content="Idyll" />
    <meta charset="utf-8" />
    <meta property="og:type" content="article" />

    <meta property="og:description" content="Short description of your project" />
    <meta property="description" content="Short description of your project" />
    <link
      rel="stylesheet"
      href="//cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0/katex.min.css"
    />

    <link rel="stylesheet" href="static/idyll_styles.css" />
  </head>
  <body>
    <div id="idyll-mount"><div data-reactroot=""><div class="idyll-root"><div class=" idyll-text-container"></div><div class="article-header" style="background:#222222;color:#ffffff"><h1 class="hed">Network Flow</h1><h2 class="dek">Introduction to Network Flow, Max-Flow/Min-Cut, and the Ford-Fulkerson Algorithm</h2><div class="byline">By: <a>Eshan Tarneja, Alex Alwan, and Michael Tamkin</a></div><div class="idyll-pub-date">Sun Aug 23 2020</div></div><div class=" idyll-text-container"><h2 id="welcome!">Welcome!</h2><p>This post was written using a component-based library called Idyll.  It was created with the primary purpose of explaining network flow and the maximum flow algorithm.  As you explore, you will see various buttons and sliders to interact with.  You may use them to play animations and perform tasks on the page.  We hope that this is a helpful tool for learning. Enjoy!

<br/><br/></p><h2 id="introduction">Introduction</h2><p>Generally speaking, the maximum flow problem can be stated as:</p><p>Given a set of nodes and edges comprising a network, an infinite input source, and a fixed maximum capacity for every edge, what is the maximum amount of flow that can pass through the network?</p><p>The maximum flow of a network is defined as the maximum amount of flow that the network would allow to pass from start (source) to finish (sink). There are numerous existing algorithms that solve this particular problem; however, the one we wish to cover is the Ford-Fulkerson algorithm.</p><h4 id="real-world-applications">Real World Applications</h4><p>There exist numerous applications of the maximum flow problem, some of which you may not have even considered!  Here are a few interesting applications:</p><ol><li>Baseball Playoff Elimination</li><li>Airline scheduling</li><li>Circulation-demand problem</li><li>Fairness in car sharing (carpooling)</li></ol><p>
You can learn more about these applications and how they apply to the maximum flow problem <a text="here" url="https://en.wikipedia.org/wiki/Maximum_flow_problem#Real_world_applications" href="https://en.wikipedia.org/wiki/Maximum_flow_problem#Real_world_applications">here</a>.</p><br/><h2 id="understanding-network-graphs">Understanding Network Graphs</h2><p>As mentioned previously, the key parts of network graphs are nodes, edges, and capacities.</p><p>There are two key nodes to be aware of: the source(S) and the sink(T). The source is where the flow starts from in the network, and the sink is where in “drains out of”. The other nodes in between are stops along the way.</p><p>Although network graphs may have undirected edges, the graphs specific to flow networks only contain directed edges.  This means that flow can only move one direction through an edge.</p><p>Additionally, each edge within the network has a fixed capacity. The amount of flow through an edge cannot exceed the capacity of the edge.</p><p>Click through the buttons below to familiarize yourself with different components of network flow!

</p><div class="d3-component-container"><div class="d3-component" style="width:100%"></div></div><button class="showVert"> Vertices </button><button class="showEdge"> Edges </button><button class="showCap"> Capacities </button><button class="showNet"> Network Flow </button><br/><br/><p>For those who are more mathematically inclined, you may think of a flow network as a tuple, <span style="display:inline-block"><span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mo>=</mo><mo>(</mo><mi>V</mi><mo separator="true">,</mo><mi>E</mi><mo separator="true">,</mo><mi>s</mi><mo separator="true">,</mo><mi>t</mi><mo separator="true">,</mo><mi>c</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">G = (V, E, s, t, c)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit">G</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">s</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">t</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">c</span><span class="mclose">)</span></span></span></span> </span></span>.  Essentially, it is comprised of a Digraph<span style="display:inline-block"><span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>V</mi><mo separator="true">,</mo><mi>E</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(V,E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span> </span></span> (a set of vertices and edges) with source, <span style="display:inline-block"><span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>∈</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">s \in V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="base"><span class="mord mathit">s</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord mathit" style="margin-right:0.22222em;">V</span></span></span></span> </span></span>, and sink, <span style="display:inline-block"><span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mo>∈</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">t \in V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="base"><span class="mord mathit">t</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord mathit" style="margin-right:0.22222em;">V</span></span></span></span> </span></span>. Additionally, for each edge, <span style="display:inline-block"><span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mo>∈</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">e \in E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="base"><span class="mord mathit">e</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord mathit" style="margin-right:0.05764em;">E</span></span></span></span> </span></span>, there exists a non-negative capacity <span style="display:inline-block"><span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>c</mi><mi>e</mi></msub></mrow><annotation encoding="application/x-tex">c_e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> </span></span>. A flow through an edge is defined as <span style="display:inline-block"><span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>e</mi></msub></mrow><annotation encoding="application/x-tex">f_e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> </span></span>.</p><br/><h2 id="maximum-flow-problem">Maximum Flow Problem</h2><p>The maxiumum flow problem simply asks, given one of these flow networks with vertices, edges, and capacities - what is the maximum amount of flow that can be pushed through it?</p><p>There are two main constraints that your “maximum flow” needs to follow to be considered a true maximum flow. Mathmatically speaking: An st-flow, <span style="display:inline-block"><span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10764em;">f</span></span></span></span> </span></span>, is a function that satisfies the following contraints:</p><ul><li>(Capacity) - For each <span style="display:inline-block"><span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mo>∈</mo><mi>E</mi><mo>:</mo><mn>0</mn><mo>≤</mo><msub><mi>f</mi><mi>e</mi></msub><mo>≤</mo><msub><mi>c</mi><mi>e</mi></msub></mrow><annotation encoding="application/x-tex">e \in E:  0 \leq f_e \leq c_e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit">e</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathit">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> </span></span></li></ul><ul><li>(Flow conservation) - For each <span style="display:inline-block"><span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mo>∈</mo><mi>V</mi><mo>−</mo><mo>(</mo><mrow><mi>s</mi><mo separator="true">,</mo><mi>t</mi></mrow><mo>)</mo><mo>:</mo><mi mathvariant="normal">Σ</mi><msub><mi>f</mi><mi>e</mi></msub></mrow><annotation encoding="application/x-tex">v \in V - ({s,t}):  \Sigma f_e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.03588em;">v</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord mathit" style="margin-right:0.22222em;">V</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathit">s</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">t</span></span><span class="mclose">)</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord">Σ</span><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> </span></span>  (e out of v) <span style="display:inline-block"><span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>=</mo><mi mathvariant="normal">Σ</mi><msub><mi>f</mi><mi>e</mi></msub></mrow><annotation encoding="application/x-tex">= \Sigma f_e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord">Σ</span><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> </span></span> (e in to v)</li></ul><p>
In other words, a maximum possible flow from S to T exists based on these two constraints:</p><ul><li>Flow on an edge doesn’t exceed the given capacity of the edge.</li></ul><ul><li>Incoming flow is equal to outgoing flow for every vertex in the network, except for the source (S) and sink (T).</li></ul><p>
The value of flow, <span style="display:inline-block"><span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10764em;">f</span></span></span></span> </span></span>, is:</p><ul><li><span style="display:inline-block"><span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi><mo>(</mo><mi>f</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">val(f)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.03588em;">v</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span> </span></span> = <span style="display:inline-block"><span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Σ</mi><msub><mi>f</mi><mi>e</mi></msub></mrow><annotation encoding="application/x-tex">\Sigma f_e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord">Σ</span><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> </span></span>  (e out of v)  -  <span style="display:inline-block"><span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Σ</mi><msub><mi>f</mi><mi>e</mi></msub></mrow><annotation encoding="application/x-tex">\Sigma f_e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord">Σ</span><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> </span></span> (e in to v)</li></ul><p>
In the graph below you can see a few examples of what is and is not considered maximum flow.</p><div class="d3-component-container"><div class="d3-component" style="width:100%"></div></div><button class="capEx"> Capacity Exceeded</button><button class="notMaxFlow"> Sub-optimal Flow </button><button class="maxFlow"> Optimal Flow </button><br/><br/><h2 id="max-flow,-min-cut-theorem">Max-flow, Min-cut Theorem</h2><p>A quick way to find the maximum flow of a network is to use the “max-flow, min-cut” theorem. The theorem provides a method of finding the the tightest bottleneck in the network by examining all the possible bottlenecks one by one.</p><p>To find these bottlnecks, the method takes all of the possible s-t cuts of the network, and compares their capacity.  So what is an s-t cut exactly?  An s-t cut is a partitioning of the vertices into two disjoint subsets; one subset will contain the source (S) and the other will contain the sink (T). One interesting way of envisioning this s-t cut is using set theory (A and B are the two disjoint subsets).</p><ul><li><span style="display:inline-block"><span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>∪</mo><mi>B</mi><mo>∈</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">A \cup B \in V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="base"><span class="mord mathit">A</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord mathit" style="margin-right:0.22222em;">V</span></span></span></span> </span></span> (the union of A and B is the original network)</li></ul><ul><li><span style="display:inline-block"><span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>∩</mo><mi>B</mi><mo>=</mo><mi mathvariant="normal">∅</mi></mrow><annotation encoding="application/x-tex">A \cap B = \varnothing</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.765em;vertical-align:-0.08167em;"></span><span class="base"><span class="mord mathit">A</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord amsrm">∅</span></span></span></span> </span></span> (the intersection of A and B is an empty set)</li></ul><p>
The goal of this cut is to find the capacity of the edges that cross the partition made by the cut.  Again, the smallest capacity cut will dictate the maximum capacity flow that is feasible within the flow network. Explore the min cut method in the animation below!

</p><div class="d3-component-container"><div class="d3-component" style="width:100%"></div></div><button class="simpleExample"> Play Animation </button><br/><h2 id="finding-the-maximum-flow-path-with-a-greedy-approach">Finding the Maximum Flow Path With a Greedy Approach</h2><p>Once you’ve found the maximum flow, the next step will be to identify the path of flow needed to achieve this final value.</p><p>A simple way to first try and solve this problem is with a “greedy” approach.  Let us define what that would look like below:</p><ol><li>Start with <span style="display:inline-block"><span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>e</mi></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f_e = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span></span> </span></span> for each edge <span style="display:inline-block"><span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mo>∈</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">e \in E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="base"><span class="mord mathit">e</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord mathit" style="margin-right:0.05764em;">E</span></span></span></span> </span></span>.</li><li>Find path P from source to sink, S ↝ T, where each edge has <span style="display:inline-block"><span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>e</mi></msub><mo>&lt;</mo><msub><mi>c</mi><mi>e</mi></msub></mrow><annotation encoding="application/x-tex">f_e &lt; c_e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathit">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> </span></span>.</li><li>Augment flow along path P.</li><li>Repeat until you get stuck.</li></ol><p>
Lets see how this process would work below!

</p><div class="d3-component-container"><div class="d3-component" style="width:100%"></div></div><button class="simpleExample"> Play Animation </button><br/><br/><p>Given the path that greedy returns, only 10 units of flow make it to the end, which is far below our goal of 15!

While greedy is a simple method that will allow us to push flow through a network, in many cases like this a greedy solve is sub-optimal.</p><p>Accordingly, there exists a better path that is able to push additional flow optimally through the network. To find this path, we need to find an approach that allows us to “back track”, and remove flow in our current path so we can push it somewhere better.</p><br/><h2 id="residual-network-flow">Residual Network Flow</h2><p>To backtrack in the way we want, we need a map of not only where we can push flow forwards, but also where we can push flow backwards. This map will be the “residual network”</p><p>For every flow network, G, that pushes flow from source to sink, there exists a residual network, R, that goes from sink to source. This residual network shares the same set of vertices as the original network, G.  Additionally, for each edge <span style="display:inline-block"><span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mo>=</mo><mo>(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo>)</mo><mo>∈</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">e = (u,v) \in G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit">e</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord mathit">u</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord mathit">G</span></span></span></span> </span></span>, there exists the following in the residual network, R:</p><ul><li>A forward edge <span style="display:inline-block"><span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>e</mi><mo mathvariant="normal">′</mo></msup><mo>=</mo><mo>(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">e&#x27; = (u,v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="base"><span class="mord"><span class="mord mathit">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord mathit">u</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span> </span></span> with capacity <span style="display:inline-block"><span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>c</mi><mi>e</mi></msub><mo>−</mo><msub><mi>f</mi><mi>e</mi></msub></mrow><annotation encoding="application/x-tex">c_e - f_e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord"><span class="mord mathit">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> </span></span>, if <span style="display:inline-block"><span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>c</mi><mi>e</mi></msub><mo>−</mo><msub><mi>f</mi><mi>e</mi></msub><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">c_e - f_e  &gt; 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord"><span class="mord mathit">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span></span> </span></span></li></ul><ul><li>A backward edge <span style="display:inline-block"><span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>e</mi><mrow><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo></mrow></msup><mo>=</mo><mo>(</mo><mi>v</mi><mo separator="true">,</mo><mi>u</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">e&#x27;&#x27; = (v,u)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="base"><span class="mord"><span class="mord mathit">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">u</span><span class="mclose">)</span></span></span></span> </span></span> with capacity <span style="display:inline-block"><span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>e</mi></msub></mrow><annotation encoding="application/x-tex">f_e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> </span></span>, if <span style="display:inline-block"><span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>e</mi></msub><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f_e  &gt; 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span></span> </span></span></li></ul><p>
The forward edge of a residual graph has a value entitled the, “residual capacity,” which is equal to the original capacity of the edge minus the current flow through it. Effectively, the residual capacity is the current capacity of the edge.</p><p>The backwards edge of a residual graph holds that value of flow that is currently passing through the edge.  This value is updated in each step of the algorithm.</p><p>You can think of the residual graph as showing you the amount of flow that can be pushed both forwards and backwards among an edge.</p><p>Here is an example of how a single flow changes the capacity and residual capacity: the red numbers show the residual capacity while the blue numbers show the actual capacity and the amount of flow passing through the edge.</p><div class="d3-component-container"><div class="d3-component" style="width:100%"></div></div><button class="simpleExample"> Play Animation </button><br/><br/><h2 id="ford-fulkerson-algorithm">Ford-Fulkerson Algorithm</h2><p>The Ford-Fulkerson Algorithm uses the concept of residual graphs to move forwards and backwards towards a path of maximum flow! The algorithm was developed in 1956 by L. R. Ford, Jr. and D. R. Fulkerson and their method is widely used today!

To find the maximum flow, the Ford-Fulkerson algorithm repeatedly searches for and finds augmenting paths using the residual network graph. This process repeats as flow is augmented through the network until no more augmenting paths are found in the network.</p><p>An augmenting path is a path of edges in the residual graph with unused capacity greater than zero, <span style="display:inline-block"><span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>e</mi></msub><mo>&lt;</mo><msub><mi>c</mi><mi>e</mi></msub></mrow><annotation encoding="application/x-tex">f_e &lt; c_e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathit">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> </span></span>, from source (S) to sink (T).</p><p>A pseudocode for this algorithm is given below.  The inputs required are graph G, source node S, and sink node T.</p><pre><code>function: FordFulkerson(Graph G, Node S, Node T):
    Initialise flow in all edges to 0
    while (there exists an augmenting path(P) between S and T in residual network graph):
        Augment flow between S to T along the path P
        Update residual network graph
    return</code></pre><p>
In this implementation of the Ford-Fulkerson algorithm, the maximum flow will be reached when no more flow augmenting paths can be found in the graph.</p><p>Here is an example of a complete run through of the algorithm, where you can see the maximum flow of 15 is reached!:</p><div class="d3-component-container"><div class="d3-component" style="width:100%"></div></div><button class="simpleExample"> Play Animation </button><h3 id="time-complexity">Time Complexity</h3><p>The time complexity for the above algorithm is <span style="display:inline-block"><span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>E</mi><mi>f</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(Ef)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span> </span></span>, where E is the number of edges in the graph and f is the maximum flow of the graph. This is because each augmenting path can be found in <span style="display:inline-block"><span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>E</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span> </span></span> time and increases the flow by an integer amount of at least 1, with the upper bound, <span style="display:inline-block"><span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10764em;">f</span></span></span></span> </span></span>.</p><p>Note: this complexity only holds if the capacities of the graph are integers.</p><p>A variation of the Ford–Fulkerson algorithm with guaranteed termination and a runtime independent of the maximum flow value is the Edmonds–Karp algorithm, which runs in   <span style="display:inline-block"><span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>V</mi><msup><mi>E</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(VE^{2})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.22222em;">V</span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> </span></span> time.  You may read more about this implementation <a text="here" url="https://www.geeksforgeeks.org/ford-fulkerson-algorithm-for-maximum-flow-problem/" href="https://www.geeksforgeeks.org/ford-fulkerson-algorithm-for-maximum-flow-problem/">here</a>.  However, the general idea is to use a breadth-first search (BFS) coupled with the Ford Fulkerson implementation.  BFS is key to this implementation, as it always picks a path with minimum number of edges.</p><br/><br/><h1 id="test-your-knowledge">Test your Knowledge</h1><h2 id="question-1.-minimum-cut">Question 1. Minimum Cut</h2><p>Use the Min Cut Method to calulate the Maximum Flow in the following network:  <select options="select,17,18,20,23"><option selected="" value="select">select</option><option value="17">17</option><option value="18">18</option><option value="20">20</option><option value="23">23</option></select></p><div></div><div style="display:none"> Correct!<button class="helpButton">Click For Walkthrough</button></div><div style="display:none"> Incorrect! Click to see answer or try again. <button class="helpButton">Show Answer</button></div><div style="display:none"> Incorrect! Click to see answer or try again. <button class="helpButton">Show Answer</button></div><div style="display:none"> Incorrect! Click to see answer or try again. <button class="helpButton">Show Answer</button></div><div class="new-component-container"><div class="new-component" style="width:100%"></div></div><h2 id="question-2.-ford-fulkerson">Question 2. Ford Fulkerson</h2><p>Using the Ford Fulkerson Algorithm, calculate the flow through each edge needed to achieve maximum flow:</p><p>S-&gt;A: <input type="range" value="0" min="0" max="9" step="1"/> <span class="idyll-display rightMarg">0.00</span> S-&gt;C: <input type="range" value="0" min="0" max="9" step="1"/> <span class="idyll-display rightMarg">0.00</span></p><p>A-&gt;B: <input type="range" value="0" min="0" max="8" step="1"/><span class="idyll-display rightMarg">0.00</span> A-&gt;C: <input type="range" value="0" min="0" max="10" step="1"/> <span class="idyll-display">0.00</span></p><p>B-&gt;T: <input type="range" value="0" min="0" max="10" step="1"/> <span class="idyll-display rightMarg">0.00</span> C-&gt;D: <input type="range" value="0" min="0" max="3" step="1"/> <span class="idyll-display">0.00</span></p><p>C-&gt;B: <input type="range" value="0" min="0" max="1" step="1"/> <span class="idyll-display rightMarg">0.00</span> D-&gt;B: <input type="range" value="0" min="0" max="8" step="1"/> <span class="idyll-display">0.00</span></p><p>D-&gt;T: <input type="range" value="0" min="0" max="7" step="1"/> <span class="idyll-display">0.00</span></p><p><button class="helpButton">Submit</button><button class="helpButton"> Reset </button> <button class="helpButton">Show Answer</button></p><div style="display:none"><div style="display:none"><div style="display:none"><div style="display:none"><div style="display:none"><div style="display:none"><div style="display:none"><div><div style="display:none"><div style="display:none"><span class="idyll-display">Correct!</span></div></div></div></div></div></div></div></div></div></div><div style="display:none"><div><span class="idyll-display">Incorrect! Click reset and try again, or click show answer for help.</span></div></div><div class="new-component-container"><div style="width:100%"></div></div></div></div></div></div>
    <script src="static/idyll_index.js"></script>
  </body>
</html>
